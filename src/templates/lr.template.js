/**
 * LR parser generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode <parsing-mode> \
 *     --output ~/path-to-output-parser-file.js
 */

'use strict';

let yytext;
let yyleng;
let yy = {};
let __;
let __loc;

function yyloc(start, end) {
  // Epsilon doesn't produce location.
  if (!start || !end) {
    return start || end;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn,
  };
}

let shouldCaptureLocations = <<CAPTURE_LOCATIONS>>;

const EOF = '$';

const ps = <<PRODUCTIONS>>;
const tks = <<TOKENS>>;
const tbl = <<TABLE>>;

const s = [];

let tokenizer;
<<TOKENIZER>>

/**
 * Expose tokenizer so it can be accessed in semantic actions.
 */
yy.lexer = tokenizer;
yy.tokenizer = tokenizer;

const yyparse = {
  parse(string) {
    yyparse.onParseBegin(string);

    if (!tokenizer) {
      throw new Error(`Tokenizer instance wasn't specified.`);
    }

    tokenizer.initString(string);

    s.length = 0;
    s.push(0);

    let token = tokenizer.getNextToken();
    let st = null;

    do {
      if (!token) {
        unexpectedEndOfInput();
      }

      let sta = s[s.length - 1];
      let clm = tks[token.type];
      let entry = tbl[sta][clm];

      if (!entry) {
        unexpectedToken(token);
      }

      if (entry[0] === 's') {
        let loc = null;

        if (shouldCaptureLocations) {
          loc = {
            startOffset: token.startOffset,
            endOffset: token.endOffset,
            startLine: token.startLine,
            endLine: token.endLine,
            startColumn: token.startColumn,
            endColumn: token.endColumn,
          };
        }

        s.push(
          {symbol: tks[token.type], semanticValue: token.value, loc},
          Number(entry.slice(1))
        );
        st = token;
        token = tokenizer.getNextToken();
      } else if (entry[0] === 'r') {
        let pn = entry.slice(1);
        let production = ps[pn];
        let hasSemanticAction = typeof production[2] === 'function';
        let semanticValueArgs = hasSemanticAction ? [] : null;

        const locationArgs = (
          hasSemanticAction && shouldCaptureLocations
            ? []
            : null
        );

        if (production[1] !== 0) {
          let rhsl = production[1];
          while (rhsl--) {
            s.pop();
            let stackEntry = s.pop();

            if (hasSemanticAction) {
              semanticValueArgs.unshift(stackEntry.semanticValue);

              if (locationArgs) {
                locationArgs.unshift(stackEntry.loc);
              }
            }
          }
        }

        const reduceStackEntry = {symbol: production[0]};

        if (hasSemanticAction) {
          yytext = st ? st.value : null;
          yyleng = st ? st.value.length : null;

          const semanticActionArgs = (
            locationArgs !== null
              ? semanticValueArgs.concat(locationArgs)
              : semanticValueArgs
          );

          production[2](...semanticActionArgs);

          reduceStackEntry.semanticValue = __;

          if (locationArgs) {
            reduceStackEntry.loc = __loc;
          }
        }

        s.push(
          reduceStackEntry,
          tbl[s[s.length - 1]][production[0]]
        );
      } else if (entry === 'acc') {
        s.pop();
        let parsed = s.pop();

        if (s.length !== 1 ||
            s[0] !== 0 ||
            tokenizer.hasMoreTokens()) {
          unexpectedToken(token);
        }

        if (parsed.hasOwnProperty('semanticValue')) {
          yyparse.onParseEnd(parsed.semanticValue);
          return parsed.semanticValue;
        }

        yyparse.onParseEnd();
        return true;
      }

    } while (tokenizer.hasMoreTokens() || s.length > 1);
  },

  setTokenizer(customTokenizer) {
    tokenizer = customTokenizer;
    return yyparse;
  },

  getTokenizer() {
    return tokenizer;
  },

  onParseBegin(string) {},
  onParseEnd(parsed) {},
};

<<MODULE_INCLUDE>>

function unexpectedToken(token) {
  if (token.value === EOF) {
    unexpectedEndOfInput();
  }

  tokenizer.throwUnexpectedToken(
    token.value,
    token.startLine,
    token.startColumn
  );
}

function unexpectedEndOfInput() {
  parseError(`Unexpected end of input.`);
}

function parseError(message) {
  throw new SyntaxError(message);
}

module.exports = yyparse;
