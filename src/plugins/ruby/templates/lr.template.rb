##
# LR parser generated by the Syntax tool.
#
# https://www.npmjs.com/package/syntax-cli
#
#   npm install -g syntax-cli
#
#   syntax-cli --help
#
# To regenerate run:
#
#   syntax-cli \
#     --grammar ~/path-to-grammar-file \
#     --mode <parsing-mode> \
#     --output ~/ParserClassName.rb
##

class YYParse
  @@ps = <<PRODUCTIONS>>
  @@tks = <<TOKENS>>
  @@tbl = <<TABLE>>

  @@s = []
  @@__ = nil

  @@callbacks = {
    :on_parse_begin => nil,
    :on_parse_end => nil
  }

  EOF = '$'

  @@yytext = ''
  @@yyleng = 0

  def self.__=(__)
    @@__ = __
  end

  def self.yytext=(yytext)
    @@yytext = yytext
  end

  def self.yytext
    @@yytext
  end

  def self.yyleng=(yyleng)
    @@yyleng = yyleng
  end

  def self.yyleng
    @@yyleng
  end

  @@tokenizer = nil

  <<PRODUCTION_HANDLERS>>

  def self.tokenizer=(tokenizer)
    @@tokenizer = tokenizer
  end

  def self.tokenizer
    @@tokenizer
  end

  def self.on_parse_begin(&callback)
    @@callbacks[:on_parse_begin] = callback
  end

  def self.on_parse_end(&callback)
    @@callbacks[:on_parse_end] = callback
  end

  def self.parse(string)
    if (@@callbacks[:on_parse_begin])
      @@callbacks[:on_parse_begin].call(string)
    end

    tokenizer = self.tokenizer

    if not tokenizer
      raise "Tokenizer instance wasn't specified."
    end

    tokenizer.init_string(string)

    @@s = [0]

    t = tokenizer.get_next_token
    st = nil

    loop do
      if not t
        self.unexpected_end_of_input
      end

      sta = @@s[-1]
      clm = @@tks[t[:type]]
      e = @@tbl[sta][clm]

      if not e
        self.unexpected_token(t)
      end

      if e[0, 1] == 's'
        @@s.push(
          {:symbol => @@tks[t[:type]], :semantic_value => t[:value]},
          e[1..-1].to_i
        )
        st = t
        t = tokenizer.get_next_token
      elsif e[0, 1] == 'r'
        pn = e[1..-1].to_i
        p = @@ps[pn]
        hsa = p.count > 2
        saa = hsa ? [] : nil

        if p[1] != 0
          rhsl = p[1]
          while rhsl > 0
            rhsl -= 1
            @@s.pop
            se = @@s.pop
            if hsa
              saa.unshift(se[:semantic_value])
            end
          end
        end

        rse = {:symbol => p[0]}

        if hsa
          @@yytext = st ? st[:value] : nil
          @@yyleng = st ? st[:value].length : nil
          YYParse.send(p[2], *saa)
          rse[:semantic_value] = @@__
        end

        @@s.push(rse, @@tbl[@@s[-1]][p[0].to_s])

      elsif e == 'acc'
        @@s.pop
        parsed = @@s.pop

        if @@s.length != 1 || @@s[0] != 0 || tokenizer.has_more_tokens
          self.unexpected_token(t)
        end

        parsed_value = parsed.has_key?(:semantic_value) ? parsed[:semantic_value] : true

        if (@@callbacks[:on_parse_end])
          @@callbacks[:on_parse_end].call(parsed_value)
        end

        return parsed_value
      end

      if not tokenizer.has_more_tokens and @@s.length <= 1
        break
      end
    end
  end

  def self.unexpected_token(token)
    if token[:value] == self::EOF
      self.unexpected_end_of_input()
    end
    self.parse_error(
      'Unexpected token: "' + token[:value] + '" at ' +
      token[:start_line].to_s + ':' + token[:start_column].to_s + '.'
    )
  end

  def self.unexpected_end_of_input
    self.parse_error('Unexpected end of input.')
  end

  def self.parse_error(message)
    raise 'Parse error: ' + message
  end
end

<<MODULE_INCLUDE>>

<<TOKENIZER>>

class <<PARSER_CLASS_NAME>> < YYParse; end
